import json
import os
import random
import time
import random

# utils imports
from utils import compare_traits
from utils import uncover_card
from utils import load_game_stats, save_game_stats

# Streamlit-specific imports
import streamlit as st
import streamlit_shadcn_ui as ui
from streamlit_space import space
from streamlit_js_eval import streamlit_js_eval

# API-specific imports
from dotenv import load_dotenv
from openai import OpenAI


# ------------- GLOBAL VARIABLES ------------- #

#Todo:
# improve interaction with Chatgpt
# dialog window when trying to replay - sort of done
# show how many guesses are left (fix the counter bug)

# loads the .env file -> API-KEYS
load_dotenv()

#load the stats
load_game_stats()


# number of allowed guesses
guessCount = 6

# Parsed animal data
animal_data = json.load(open(r'betterAnimalDB/animals.json', 'r'))
# List of all animal names for the guessing input
animal_names = sorted([animal['name'] for animal in animal_data])

# ------------ SESSIONSTATE-VARIABLES -------------- #


# solution of the game
if 'winner' not in st.session_state:
    st.session_state['winner'] = animal_names[random.randint(0, len(animal_names) - 1)]
# count how many clues already have been used
if 'counter' not in st.session_state:
    st.session_state['counter'] = 0

# if 'traits' not in st.session_state:
#     st.session_state['traits'] = []

if 'user_guess' not in st.session_state:
    st.session_state['user_guess'] = ''

if 'user_guess_history' not in st.session_state:
    st.session_state['user_guess_history'] = []

if 'game_over' not in st.session_state:
    st.session_state['game_over'] = False

# if 'hint_requested' not in st.session_state:
#     st.session_state['hint_requested'] = False

if 'user_input' not in st.session_state:
    st.session_state['user_input'] = None

if 'clue_cards' not in st.session_state:
    st.session_state['clue_cards'] = []

if 'clue_comments' not in st.session_state:
    st.session_state['clue_comments'] = []


# ------------- HELPER FUNCTIONS ------------- #


# returns a generated comment for a clue via openai-api
def generateClueComment(clueNumber, guess, correctAnswer):
    client = OpenAI(api_key=os.getenv("OPEN-AI-KEY"))
    model = "gpt-4o-mini"
    question = f"The guess was number {clueNumber} and the guess was {guess} and the correct answer was {correctAnswer}. Write a short comment for the user about the guess. Maybe a fun fact about the animal of choice. keep it really short. DO NOT GIVE ANY HINT ABOUT THE CORRECT ANSWERS {correctAnswer} "

    chat_completion = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "user", "content": question},
        ],
    )

    return(chat_completion.choices[0].message.content)


# returns a hint generated by ChatGPT
def generateHint():
    client = OpenAI(api_key=os.getenv("OPEN-AI-KEY"))
    model = "gpt-4o-mini"
    prompt = (f"We are playing an animal guessing game, the correct answer is {st.session_state['winner']}. The user guessed {st.session_state['user_guess']} . Give a hint to the solution without naming the solution {st.session_state['winner']}. You can e.g. tell them about their skin or colour or the first letter of the animal but remember it is very important that your answer does not include the word {st.session_state['winner']}.")

    chat_completion = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "user", "content": prompt},
        ],
    )
    answer = chat_completion.choices[0].message.content

    for word in answer.split(" "):
        yield word + " "
        time.sleep(0.1)


# returns a generated comment-stream (!) for a clue via openai-api and also saves the comment inside clueComments array
def streamAndSafeClueComment(clueNumber):
    # appends the GPT-generated comment to the gobal clueComments array
    if st.session_state['clue_comments']:
        st.session_state['clue_comments'].append(generateClueComment(clueNumber, f"{st.session_state['user_guess']}", f"{st.session_state['winner']}"))
    else:
        st.session_state['clue_comments'] = [generateClueComment(clueNumber, f"{st.session_state['user_guess']}", f"{st.session_state['winner']}")]
    time.sleep(1)
    # this is how this text streaming is done in streamlit
    for word in st.session_state['clue_comments'][clueNumber].split(" "):
        yield word + " "
        # change time of text writing effect
        time.sleep(0.05)


# try to use for text input
def show_prompt():
    code = """
    let userResponse = prompt("Please enter your question about the animal:");
    if (userResponse) {
        Streamlit.setComponentValue(userResponse); // Send the response back to Streamlit
    }
    """
    result = streamlit_js_eval(code)
    return result


# ------------- RENDERING THE GAME ------------- #
st.write(f"for dev correct guess: {st.session_state['winner']}")
st.title("Animal Guessing Game")


if not st.session_state['game_over']:
    # Create a placeholder for the selectbox
    selectbox_placeholder = st.empty()

    if st.session_state['counter'] < guessCount-1:
        # dropdown for the user to select an animal name for guessing
        st.session_state['user_guess'] = selectbox_placeholder.selectbox(
                "What animal do you think this is?",
                [''] + animal_names
            )


    # if the selection box has been pressed
    if st.session_state['user_guess']:

        # the user made a correct guess
        if st.session_state['user_guess'] == st.session_state['winner']:
            save_game_stats(True)
            selectbox_placeholder.empty()
            st.write("Congratulations! You won the game!")
            if st.button("play again"):
                streamlit_js_eval(js_expressions="parent.window.location.reload()")

        elif st.session_state['user_guess']:
            st.session_state['counter'] += 1


            # user still has guesses left
            if st.session_state['counter'] < guessCount-1:
                st.info(f"You have {guessCount-st.session_state['counter']} guesses left.")
            # user has one guess left
            if st.session_state['counter'] == guessCount-1:
                st.info("This is your last guess! Use it well")
                # generate a hint
                st.text("here a little hint for your last guess:")
                with st.chat_message("ai"):
                     st.write(generateHint())
                if st.session_state['user_guess'] != st.session_state['winner']:
                    st.session_state['game_over'] = True

            if st.session_state['counter'] <= guessCount-1:
                # get the traits the guessed animal shares with the winner animal
                shared = compare_traits(st.session_state['winner'], st.session_state['user_guess'])
                st.session_state['clue_cards'].append(shared)

                st.session_state['user_guess_history'].append(st.session_state['user_guess'])
                for clue in reversed(range(st.session_state['counter'])):
                    with st.container(border=True):
                        st.title(f"Clue {clue+1}")
                        st.header(f"Your guess was: :red[{st.session_state['user_guess_history'][clue]}]")
                        space()
                        space()
                        st.write("Shared traits are: ")
                        space()
                        uncover_card(st.session_state['clue_cards'][clue])
                        space()
                        space()
                        # get a cute comment by ChatGPT
                        with st.chat_message("ai"):
                            if len(st.session_state['clue_comments']) <= clue:
                                st.write_stream(streamAndSafeClueComment(clue))
                            else:
                                st.write(st.session_state['clue_comments'][clue])
                        space()
                        space()

else:
    save_game_stats(False)
    st.write("Game over! You lost!")
    if st.button("try again"):
        # reload the page
        streamlit_js_eval(js_expressions="parent.window.location.reload()")
